!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var a=e();for(var t in a)("object"==typeof exports?exports:n)[t]=a[t]}}(window,(function(){return function(n){var e={};function a(t){if(e[t])return e[t].exports;var i=e[t]={i:t,l:!1,exports:{}};return n[t].call(i.exports,i,i.exports,a),i.l=!0,i.exports}return a.m=n,a.c=e,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)a.d(t,i,function(e){return n[e]}.bind(null,i));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="",a(a.s=3)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return getTimelineById; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getParallaxTimelineById; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getAnimationEntryById; });\n/* unused harmony export getEndOfTimeline */\n/* unused harmony export getAnimationDefinitionById */\n/* unused harmony export getAnimationDefinitionsByIds */\n/* unused harmony export calculateStartValue */\n/* unused harmony export processFrameStart */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return processAnimationConnections; });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\nvar getTimelineById = function (animationData, id) {\n    return animationData.timelines.find(function (timeline) { return (timeline.id === id); });\n};\nvar getParallaxTimelineById = function (animationData, id) {\n    return animationData.parallaxTimelines.find(function (timeline) { return (timeline.id === id); });\n};\nvar getAnimationEntryById = function (animationData, id) {\n    return (animationData.animationEntries) ? animationData.animationEntries.find(function (entry) { return (entry.id === id); }) : undefined;\n};\nvar getEndOfTimeline = function (animationData, timelineId, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    var result = 0;\n    var timeline = (parallax) ? getParallaxTimelineById(animationData, timelineId) : getTimelineById(animationData, timelineId);\n    if (!timeline) {\n        return result;\n    }\n    for (var breakpoint in timeline.animationEntries) {\n        for (var _i = 0, _a = timeline.animationEntries[breakpoint] || []; _i < _a.length; _i++) {\n            var animationEntryId = _a[_i];\n            var animationEntry = getAnimationEntryById(animationData, animationEntryId);\n            if (!animationEntry) {\n                continue;\n            }\n            if (animationEntry.animationConnections) {\n                var presets = (animationEntry.animationConnections) ? animationEntry.animationConnections : [];\n                animationEntry.animationConnections = (animationEntry.animationConnections) ? animationEntry.animationConnections : [];\n                var animationProps = processAnimationConnections(animationData, __spreadArrays([animationEntry.animationConnection], presets), parallax);\n                result = Math.max(Object(_animation__WEBPACK_IMPORTED_MODULE_0__[/* getEndFromAnimationProps */ \"b\"])(animationProps, parallax), result);\n            }\n        }\n    }\n    return result;\n};\nvar getAnimationDefinitionById = function (animationData, id) {\n    var animationDefinitions = (animationData.animationDefinitions) ? animationData.animationDefinitions : [];\n    return animationDefinitions.find(function (animationDefinition) {\n        return (id && animationDefinition.id === id) ? true : false;\n    });\n};\nvar getAnimationDefinitionsByIds = function (animationData, ids) {\n    if (!ids) {\n        return [];\n    }\n    var animationDefinitions = (animationData.animationDefinitions) ? animationData.animationDefinitions : [];\n    return ids.reduce(function (result, id) {\n        var animationDefinition = animationDefinitions.find(function (animationDefinition) { return (id === animationDefinition.id); });\n        if (animationDefinition) {\n            result.push(animationDefinition);\n        }\n        return result;\n    }, []);\n};\nvar calculateStartValue = function (animationData, startSum) {\n    var startSumValue = startSum;\n    var numberVarMatches = startSumValue.match(/\\[([a-zA-Z]*)\\]/g);\n    if (numberVarMatches && numberVarMatches.length > 0) {\n        for (var _i = 0, numberVarMatches_1 = numberVarMatches; _i < numberVarMatches_1.length; _i++) {\n            var numberVarIndex = numberVarMatches_1[_i];\n            var index = numberVarIndex.replace('[', '').replace(']', '');\n            if (numberVarIndex && animationData.numbers && animationData.numbers[index]) {\n                var value = animationData.numbers[index];\n                startSumValue = startSumValue.replace(new RegExp(\"\\\\[\" + index + \"\\\\]\", 'g'), '' + value);\n            }\n        }\n    }\n    var result = 0;\n    try {\n        result = eval(startSumValue) || 0;\n    }\n    catch (_a) {\n        result = 0;\n    }\n    return result;\n};\nvar processFrameStart = function (animationData, animationDefinition, start, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    if (!animationDefinition) {\n        return {};\n    }\n    if (!start) {\n        return animationDefinition.props;\n    }\n    var startIndex = (parallax) ? 'offsetPixels' : 'ms';\n    var startTime = calculateStartValue(animationData, start);\n    var result = JSON.parse(JSON.stringify(animationDefinition.props));\n    for (var propKey in result) {\n        for (var _i = 0, _a = result[propKey]; _i < _a.length; _i++) {\n            var frame = _a[_i];\n            frame[startIndex] = frame[startIndex] + startTime;\n        }\n    }\n    return result;\n};\nvar processAnimationConnections = function (animationData, animationConnections, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    if (!animationData) {\n        return {};\n    }\n    var animation = {};\n    for (var _i = 0, _a = animationConnections || []; _i < _a.length; _i++) {\n        var animationConnection = _a[_i];\n        if (!animationConnection) {\n            continue;\n        }\n        var animationDefinition = getAnimationDefinitionById(animationData, animationConnection.animationDefinitionId);\n        if (animationDefinition) {\n            var startIndex = (parallax) ? 'startOffsetPixels' : 'startMs';\n            var start = animationConnection[startIndex];\n            var animationProcessedFrameStart = (start) ? processFrameStart(animationData, animationDefinition, start, parallax) : animationDefinition.props;\n            animation = Object(_animation__WEBPACK_IMPORTED_MODULE_0__[/* mergeAnimations */ \"c\"])(animationProcessedFrameStart, animation, parallax);\n        }\n    }\n    return animation;\n};\n\n\n//# sourceURL=webpack:///./node_modules/variojs/lib/helpers/animationData.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export isFrameDefined */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getClosestFramesForTimeline; });\n/* unused harmony export getClosestFrames */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return mergeAnimations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getEndFromAnimationProps; });\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar isFrameDefined = function (frames, frame, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    var index = (parallax) ? 'offsetPixels' : 'ms';\n    return frames.some(function (frameToCompare) {\n        return frameToCompare[index] !== undefined && frameToCompare[index] === frame[index];\n    });\n};\nvar getClosestFramesForTimeline = function (animation, timeline, key) {\n    var frames = animation.animationProps[key];\n    var frameUnitId = (animation.parallax) ? 'offsetPixels' : 'ms';\n    var goal = timeline.progress || 0;\n    var closestsFrames = getClosestFrames(frames, goal, frameUnitId);\n    return {\n        closestsFrames: closestsFrames,\n        goal: goal,\n        frameUnitId: frameUnitId\n    };\n};\nvar getClosestFrames = function (frames, goal, frameUnitId) {\n    var result = [];\n    for (var _i = 0, frames_1 = frames; _i < frames_1.length; _i++) {\n        var frame = frames_1[_i];\n        if (frame[frameUnitId] <= goal) {\n            result[0] = frame;\n        }\n    }\n    for (var i = frames.length - 1; i >= 0; i--) {\n        if (frames[i][frameUnitId] > goal) {\n            result[1] = frames[i];\n        }\n    }\n    if (!result[0]) {\n        result[0] = frames[0];\n    }\n    if (!result[1]) {\n        result[1] = result[0];\n    }\n    return result;\n};\nvar mergeAnimations = function (animation, animationToMerge, parallax) {\n    if (animationToMerge === void 0) { animationToMerge = {}; }\n    if (parallax === void 0) { parallax = false; }\n    var result = __assign({}, animation);\n    for (var propKey in animationToMerge) {\n        if (!result[propKey]) {\n            result[propKey] = [];\n        }\n        var propToMerge = (animationToMerge[propKey]) ? animationToMerge[propKey] : [];\n        for (var _i = 0, propToMerge_1 = propToMerge; _i < propToMerge_1.length; _i++) {\n            var frame = propToMerge_1[_i];\n            if (!isFrameDefined(result[propKey], frame, parallax)) {\n                result[propKey].push(frame);\n            }\n        }\n    }\n    return result;\n};\nvar getEndFromAnimationProps = function (animationProps, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    var result = 0;\n    var unitIndex = (parallax) ? 'offsetPixels' : 'ms';\n    for (var _i = 0, _a = Object.keys(animationProps); _i < _a.length; _i++) {\n        var propKey = _a[_i];\n        var prop = animationProps[propKey];\n        if (prop && prop.constructor === Array) {\n            for (var _b = 0, prop_1 = prop; _b < prop_1.length; _b++) {\n                var frame = prop_1[_b];\n                if (frame[unitIndex]) {\n                    result = Math.max(frame[unitIndex], result);\n                }\n            }\n        }\n        else if (prop && prop[unitIndex]) {\n            result = Math.max(prop[unitIndex], result);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/variojs/lib/helpers/animation.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function() {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/browser.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/helpers/scroll.js\nvar calculatePageScroll = function (startPos) {\n    if (startPos === void 0) { startPos = 0; }\n    var documentElement = document.documentElement || document.body;\n    var scrollHeight = documentElement.scrollHeight;\n    var scrollOffset = window.pageYOffset || documentElement.scrollTop;\n    var scrollOffsetMinStart = Math.max(scrollOffset - startPos, 0);\n    var percentage = scrollOffsetMinStart / (scrollHeight - documentElement.clientHeight);\n    var scrollPercentage = Math.min(Math.max(percentage, 0), 1) * 100;\n    return {\n        scrollOffset: scrollOffsetMinStart,\n        scrollPercentage: scrollPercentage\n    };\n};\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/styling-parsers.js\nvar domStylingParser = function (element) {\n    var transforms = [];\n    if (!element) {\n        return;\n    }\n    var stylingValues = element.stylingValues;\n    if (stylingValues.display) {\n        element.domElement.style.display = "" + stylingValues.display;\n    }\n    if (stylingValues.visibility) {\n        element.domElement.style.visibility = "" + stylingValues.visibility;\n    }\n    if (stylingValues.opacity) {\n        element.domElement.style.opacity = "" + stylingValues.opacity;\n    }\n    if (stylingValues.display === "none" || stylingValues.visiblity === "hidden" || (parseFloat(stylingValues.opacity) <= 0)) {\n        return;\n    }\n    if (stylingValues.translateX || stylingValues.translateY) {\n        transforms.push("translate3d(" + (stylingValues.translateX || 0) + "px, " + (stylingValues.translateY ||\n            0) + "px, 0)");\n    }\n    if (stylingValues.scaleX || stylingValues.scaleY) {\n        transforms.push("scale3d(" + (stylingValues.scaleX || 1) + ", " + (stylingValues.scaleY || 1) + ", 1)");\n    }\n    if (stylingValues.width) {\n        element.domElement.style.width = stylingValues.width + "px";\n    }\n    if (stylingValues.height) {\n        element.domElement.style.height = stylingValues.height + "px";\n    }\n    if (stylingValues.textAdd) {\n        element.domElement.innerHTML = "" + stylingValues.textAdd;\n    }\n    if (stylingValues.rotate) {\n        element.domElement.style.display = "" + stylingValues.display;\n        transforms.push("rotate(" + (stylingValues.rotate || 0) + "deg)");\n    }\n    if (transforms.length > 0) {\n        element.domElement.style.transform = transforms.join(" ");\n    }\n};\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/breakpoints.js\nvar comparisonStrings = {\n    greaterThenOrEqual: ">=",\n    greaterThen: ">",\n    smallerThenOrEqual: "<=",\n    smallerThen: "<"\n};\nvar sortBreakpoints = function (breakpointA, breakpointB) {\n    if (breakpointA.order < breakpointB.order) {\n        return 1;\n    }\n    return -1;\n};\nvar getActiveBreakPoint = function (options, animationData) {\n    var result = \'default\';\n    if (!animationData || !animationData.breakpoints) {\n        return result;\n    }\n    for (var _i = 0, _a = animationData.breakpoints.sort(sortBreakpoints); _i < _a.length; _i++) {\n        var breakPointDefinition = _a[_i];\n        var numberRegex = /[0-9]*/g;\n        var notNumberRegex = /[^0-9]*/g;\n        var comparisonString = breakPointDefinition.definition.replace(numberRegex, "");\n        var breakpoint = parseInt(breakPointDefinition.definition.replace(notNumberRegex, ""), 10);\n        if (breakpoint && comparisonString) {\n            switch (comparisonString) {\n                case comparisonStrings.greaterThen:\n                    if (window.matchMedia("(min-width: " + (breakpoint + 1) + "px)").matches) {\n                        result = breakPointDefinition.id;\n                    }\n                    break;\n                case comparisonStrings.greaterThenOrEqual:\n                    if (window.matchMedia("(min-width: " + breakpoint + "px)").matches) {\n                        result = breakPointDefinition.id;\n                    }\n                    break;\n                case comparisonStrings.smallerThen:\n                    if (window.matchMedia("(max-width: " + (breakpoint - 1) + "px)").matches) {\n                        result = breakPointDefinition.id;\n                    }\n                    break;\n                case comparisonStrings.smallerThenOrEqual:\n                    if (window.matchMedia("(max-width: " + breakpoint + "px)").matches) {\n                        result = breakPointDefinition.id;\n                    }\n                    break;\n            }\n        }\n    }\n    return result;\n};\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/types-interfaces.js\nvar PropTypes;\n(function (PropTypes) {\n    PropTypes["translateX"] = "translateX";\n    PropTypes["translateY"] = "translateY";\n    PropTypes["width"] = "width";\n    PropTypes["height"] = "height";\n    PropTypes["scaleX"] = "scaleX";\n    PropTypes["scaleY"] = "scaleY";\n    PropTypes["opacity"] = "opacity";\n    PropTypes["rotate"] = "rotate";\n    PropTypes["display"] = "display";\n    PropTypes["playVideo"] = "playVideo";\n    PropTypes["visibility"] = "visibility";\n})(PropTypes || (PropTypes = {}));\n\n// EXTERNAL MODULE: ./node_modules/variojs/lib/helpers/animation.js\nvar helpers_animation = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/easing-functions.js\nvar EasingFunctions = {\n    linear: function (t) { return t; },\n    easeInQuad: function (t) { return t * t; },\n    // @ts-ignore:\n    easeOutQuad: function (t) { return t * (2 - t); },\n    // @ts-ignore:\n    easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\n    // @ts-ignore:\n    easeInCubic: function (t) { return t * t * t; },\n    // @ts-ignore:\n    easeOutCubic: function (t) { return (--t) * t * t + 1; },\n    // @ts-ignore:\n    easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\n    // @ts-ignore:\n    easeInQuart: function (t) { return t * t * t * t; },\n    // @ts-ignore:\n    easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\n    // @ts-ignore:\n    easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; },\n    // @ts-ignore:\n    easeInQuint: function (t) { return t * t * t * t * t; },\n    // @ts-ignore:\n    easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t; },\n    // @ts-ignore:\n    easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; },\n    // @ts-ignore:\n    easeOutElastic: function (t) { return (.04 - .04 / t) * Math.sin(25 * t) + 1; },\n    // @ts-ignore:\n    easeInElastic: function (t) { return .04 * t / (--t) * Math.sin(25 * t); },\n    // @ts-ignore:\n    easeInOutElastic: function (t) { return (t -= .5) < 0 ? (.02 + .01 / t) * Math.sin(50 * t) : (.02 - .01 / t) * Math.sin(50 * t) + 1; }\n};\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/value-parsers.js\n\n\n\nvar parseStringFrames = function (_a) {\n    var animation = _a.animation, timeline = _a.timeline, key = _a.key;\n    var closestsFrames = Object(helpers_animation["a" /* getClosestFramesForTimeline */])(animation, timeline, key).closestsFrames;\n    if (!closestsFrames[0]) {\n        return;\n    }\n    return closestsFrames[0].value;\n};\nvar parseNumberFrames = function (_a) {\n    var animation = _a.animation, timeline = _a.timeline, key = _a.key;\n    var _b = Object(helpers_animation["a" /* getClosestFramesForTimeline */])(animation, timeline, key), closestsFrames = _b.closestsFrames, goal = _b.goal, frameUnitId = _b.frameUnitId;\n    if (!closestsFrames[0]) {\n        return;\n    }\n    var startValue = closestsFrames[0].value;\n    var startFrame = closestsFrames[0][frameUnitId];\n    var endValue = closestsFrames[1].value;\n    var endFrame = closestsFrames[1][frameUnitId];\n    if ((!startValue && startValue != 0) ||\n        (!startFrame && startFrame != 0) ||\n        (!endValue && endValue != 0) ||\n        (!endFrame && endFrame != 0)) {\n        return;\n    }\n    var easingFunction = (closestsFrames[1].easing) ? EasingFunctions[closestsFrames[1].easing] : EasingFunctions.linear;\n    var factor = easingFunction((goal - startFrame) / (endFrame - startFrame));\n    factor = Math.min(Math.max(factor, 0), 1);\n    var value = startValue + (endValue - startValue) * factor;\n    var devideBy = key === PropTypes.scaleX ||\n        key === PropTypes.scaleY ||\n        key === PropTypes.opacity\n        ? 100\n        : 1;\n    return "" + value / devideBy;\n};\nvar parserMap = {\n    translateX: parseNumberFrames,\n    translateY: parseNumberFrames,\n    width: parseNumberFrames,\n    height: parseNumberFrames,\n    scaleX: parseNumberFrames,\n    scaleY: parseNumberFrames,\n    rotate: parseNumberFrames,\n    opacity: parseNumberFrames,\n    display: parseStringFrames,\n    visibility: parseStringFrames,\n};\n/* harmony default export */ var value_parsers = (parserMap);\n\n// EXTERNAL MODULE: ./node_modules/variojs/lib/helpers/animationData.js\nvar animationData = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/variojs/lib/index.js\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar lib_animations = [];\nvar lib_elements = {};\nvar options;\nvar timelineStates = {};\nvar parallaxTimelineStates = {};\nvar lib_animationData;\nvar activeBreakpoint = \'default\';\nvar updateTimelines = function (timestamp) {\n    for (var _i = 0, _a = lib_animationData.timelines; _i < _a.length; _i++) {\n        var timeline = _a[_i];\n        timelineStates[timeline.id] = (timelineStates[timeline.id]) ? timelineStates[timeline.id] : {\n            id: timeline.id\n        };\n        var timelineState = timelineStates[timeline.id];\n        if (timelineState.isRunning && !timelineState.pause) {\n            if (!timelineState.start)\n                timelineState.start = timestamp;\n            var pauseTime = (timelineState.pauseTime) ? timelineState.pauseTime : 0;\n            timelineState.progress = (timestamp - timelineState.start) - pauseTime;\n            if (timelineState.end && timelineState.progress >= timelineState.end) {\n                timelineState.start = timestamp - pauseTime;\n                if (!timeline.loop) {\n                    timelineState.isRunning = false;\n                }\n            }\n        }\n        else if (timelineState.isRunning && timelineState.pause && timelineState.progress) {\n            if (!timelineState.start)\n                timelineState.start = timestamp;\n            timelineState.pauseTime = (timestamp - timelineState.start) - timelineState.progress;\n        }\n    }\n};\nvar updateParallaxTimelines = function () {\n    var scrollOffset = calculatePageScroll().scrollOffset;\n    for (var _i = 0, _a = lib_animationData.parallaxTimelines; _i < _a.length; _i++) {\n        var timeline = _a[_i];\n        parallaxTimelineStates[timeline.id] = (parallaxTimelineStates[timeline.id]) ? parallaxTimelineStates[timeline.id] : {\n            id: timeline.id\n        };\n        var timelineState = parallaxTimelineStates[timeline.id];\n        timelineState.progress = scrollOffset;\n    }\n};\nvar updateAnimations = function (animations) {\n    if (animations === void 0) { animations = []; }\n    for (var i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        for (var _i = 0, _a = Object.keys(animation.animationProps); _i < _a.length; _i++) {\n            var animationKey = _a[_i];\n            var parser = value_parsers[animationKey];\n            var timeline = (animation.parallax) ? getActiveParallaxTimelineState() : timelineStates[animation.timeline];\n            if (parser && timeline && lib_elements[animation.domReference]) {\n                lib_elements[animation.domReference].stylingValues[animationKey] = parser({\n                    animation: animation,\n                    key: animationKey,\n                    timeline: timeline\n                });\n            }\n        }\n    }\n};\nvar updateElements = function () {\n    for (var _i = 0, _a = Object.keys(lib_elements); _i < _a.length; _i++) {\n        var elementKey = _a[_i];\n        var element = lib_elements[elementKey];\n        if (typeof window !== \'undefined\') {\n            domStylingParser(element);\n        }\n    }\n};\nvar getActiveParallaxTimelineState = function () {\n    return parallaxTimelineStates[lib_animationData.activeParallaxTimeline];\n};\nvar fillElementsArray = function (animationEntries) {\n    for (var _i = 0, _a = animationEntries || []; _i < _a.length; _i++) {\n        var animationEntryId = _a[_i];\n        var animationEntry = Object(animationData["a" /* getAnimationEntryById */])(lib_animationData, animationEntryId);\n        if (!animationEntry) {\n            continue;\n        }\n        var domElement = document.querySelector("[data-v=" + animationEntry.domReference + "]");\n        if (!domElement) {\n            continue;\n        }\n        lib_elements[animationEntry.domReference] = {\n            domElement: domElement,\n            stylingValues: {}\n        };\n    }\n};\nvar prepareTimelinState = function (animation, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    var timeline = (!parallax) ? Object(animationData["c" /* getTimelineById */])(lib_animationData, animation.timeline) : Object(animationData["b" /* getParallaxTimelineById */])(lib_animationData, animation.timeline);\n    if (!timeline) {\n        return;\n    }\n    if (!parallax) {\n        timelineStates[timeline.id] = (timelineStates[timeline.id]) ? timelineStates[timeline.id] : {\n            id: timeline.id\n        };\n    }\n    var timelineState = (parallax) ? getActiveParallaxTimelineState() : timelineStates[timeline.id];\n    if (timelineState) {\n        var end = (timelineState.end) ? timelineState.end : 0;\n        timelineState.end = Math.max(Object(helpers_animation["b" /* getEndFromAnimationProps */])(animation.animationProps), end);\n    }\n};\nvar updateExistingAnimations = function (animation, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    var isUpdated = false;\n    lib_animations = lib_animations.reduce(function (result, animationDef) {\n        if (animationDef.parallax === animation.parallax &&\n            animationDef.domReference === animation.domReference &&\n            animationDef.timeline === animation.timeline) {\n            result.push(__assign(__assign({}, animationDef), { animationProps: Object(helpers_animation["c" /* mergeAnimations */])(animationDef.animationProps, animation.animationProps, parallax) }));\n            isUpdated = true;\n        }\n        else {\n            result.push(animationDef);\n        }\n        return result;\n    }, []);\n    return isUpdated;\n};\nvar processTimelineEntries = function (entries, timelineId, parallax) {\n    if (parallax === void 0) { parallax = false; }\n    for (var _i = 0, _a = entries || []; _i < _a.length; _i++) {\n        var animationEntryId = _a[_i];\n        var animationEntry = Object(animationData["a" /* getAnimationEntryById */])(lib_animationData, animationEntryId);\n        if (!animationEntry) {\n            continue;\n        }\n        var animationProps = {};\n        animationEntry.animationConnections = (animationEntry.animationConnections) ? animationEntry.animationConnections : [];\n        animationProps = Object(animationData["d" /* processAnimationConnections */])(lib_animationData, __spreadArrays(animationEntry.animationConnections, [animationEntry.animationConnection]), parallax);\n        var animation = {\n            domReference: animationEntry.domReference,\n            timeline: timelineId,\n            parallax: parallax,\n            animationProps: animationProps,\n        };\n        prepareTimelinState(animation, parallax);\n        if (!updateExistingAnimations(animation, parallax)) {\n            lib_animations.push(animation);\n        }\n    }\n};\nvar processTimelines = function () {\n    if (!lib_animationData) {\n        return;\n    }\n    for (var _i = 0, _a = lib_animationData.timelines; _i < _a.length; _i++) {\n        var timeline = _a[_i];\n        if (timeline.animationEntries) {\n            fillElementsArray(timeline.animationEntries[\'default\']);\n            fillElementsArray(timeline.animationEntries[activeBreakpoint]);\n            processTimelineEntries(timeline.animationEntries[activeBreakpoint], timeline.id);\n            processTimelineEntries(timeline.animationEntries[\'default\'], timeline.id);\n        }\n    }\n    var paralaxTimeline = Object(animationData["b" /* getParallaxTimelineById */])(lib_animationData, lib_animationData.activeParallaxTimeline);\n    if (paralaxTimeline) {\n        if (paralaxTimeline.animationEntries) {\n            fillElementsArray(paralaxTimeline.animationEntries[\'default\']);\n            fillElementsArray(paralaxTimeline.animationEntries[activeBreakpoint]);\n            processTimelineEntries(paralaxTimeline.animationEntries[activeBreakpoint], paralaxTimeline.id, true);\n            processTimelineEntries(paralaxTimeline.animationEntries[\'default\'], paralaxTimeline.id, true);\n        }\n    }\n};\nvar loopUpdateAnimations = function (timestamp) {\n    updateAnimations(lib_animations);\n    updateTimelines(timestamp);\n    updateElements();\n    updateParallaxTimelines();\n    requestAnimationFrame(loopUpdateAnimations);\n};\nvar fetchAnimationJSON = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var result;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!options.url) {\n                    return [2 /*return*/];\n                }\n                return [4 /*yield*/, window.fetch(options.url)];\n            case 1:\n                result = _a.sent();\n                return [4 /*yield*/, result.json()];\n            case 2: return [2 /*return*/, _a.sent()];\n        }\n    });\n}); };\nvar setupBreakpointHandler = function () {\n    activeBreakpoint = getActiveBreakPoint(options, lib_animationData);\n    window.addEventListener("resize", function () {\n        var newActiveBreakpoint = getActiveBreakPoint(options, lib_animationData);\n        if (newActiveBreakpoint !== activeBreakpoint) {\n            activeBreakpoint = newActiveBreakpoint;\n            lib_init();\n        }\n    });\n};\nvar play = function (timelineId) {\n    var timelineTarget = (timelineId) ? timelineId : \'main\';\n    var timeline = timelineStates[timelineTarget];\n    if (timeline) {\n        timeline.pause = false;\n        timeline.isRunning = true;\n    }\n};\nvar pause = function (timelineId) {\n    var timelineTarget = (timelineId) ? timelineId : \'main\';\n    var timeline = timelineStates[timelineTarget];\n    if (timeline) {\n        timeline.pause = true;\n    }\n};\nvar prepareMainTimelines = function () {\n    lib_animationData.timelines = (lib_animationData.timelines) ? lib_animationData.timelines : [];\n    if (!Object(animationData["c" /* getTimelineById */])(lib_animationData, \'main\')) {\n        lib_animationData.timelines = __spreadArrays(lib_animationData.timelines, [\n            {\n                id: \'main\'\n            }\n        ]);\n    }\n    lib_animationData.parallaxTimelines = (lib_animationData.parallaxTimelines) ? lib_animationData.parallaxTimelines : [];\n    if (!Object(animationData["b" /* getParallaxTimelineById */])(lib_animationData, \'main\')) {\n        lib_animationData.parallaxTimelines = __spreadArrays(lib_animationData.parallaxTimelines, [\n            {\n                id: \'main\'\n            }\n        ]);\n    }\n};\nvar lib_init = function (optionsParam) { return __awaiter(void 0, void 0, void 0, function () {\n    var animationDataFetch;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                options = __assign({}, optionsParam);\n                return [4 /*yield*/, fetchAnimationJSON()];\n            case 1:\n                animationDataFetch = _a.sent();\n                if (animationDataFetch) {\n                    lib_animationData = animationDataFetch;\n                }\n                prepareMainTimelines();\n                setupBreakpointHandler();\n                processTimelines();\n                requestAnimationFrame(loopUpdateAnimations);\n                return [2 /*return*/];\n        }\n    });\n}); };\n/* harmony default export */ var lib = ({\n    init: lib_init,\n    play: play,\n    pause: pause,\n    getAnimationData: function () {\n        return lib_animationData;\n    },\n    getOptions: function () {\n        return options;\n    },\n    setAnimationData: function (animationDataValue) {\n        lib_animationData = animationDataValue;\n        lib_elements = {};\n        lib_animations = [];\n        processTimelines();\n    }\n});\n\n// CONCATENATED MODULE: ./src/socket-server/client/socket-connect.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nvar socket_connect_ws;\n/* harmony default export */ var socket_connect = (/*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!socket_connect_ws) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt("return", socket_connect_ws);\n\n        case 2:\n          return _context.abrupt("return", new Promise(function (resolve) {\n            socket_connect_ws = new WebSocket(\'ws://localhost:8081\');\n            socket_connect_ws.addEventListener(\'open\', function (event) {\n              resolve(socket_connect_ws);\n            });\n          }));\n\n        case 3:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n})));\n// CONCATENATED MODULE: ./src/lib.js\nfunction lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction lib_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nvar lib_WebSocket = __webpack_require__(2);\n\n\n\n/* harmony default export */ var src_lib = __webpack_exports__["default"] = ({\n  init: function () {\n    var _init = lib_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(variojs) {\n      var ws;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return socket_connect();\n\n            case 2:\n              ws = _context.sent;\n              window.addEventListener(\'scroll\', function () {\n                ws.send(JSON.stringify({\n                  action: \'calculatePageScroll\',\n                  payload: calculatePageScroll()\n                }));\n              });\n              ws.addEventListener(\'message\', function (event) {\n                var data = event.data;\n                var dataParsed = JSON.parse(data);\n\n                if (dataParsed.action === \'getInitialData\') {\n                  var domNodes = [].slice.call(document.querySelectorAll(\'[data-v]\'));\n                  ws.send(JSON.stringify({\n                    action: \'initialData\',\n                    payload: {\n                      animationData: variojs.getAnimationData(),\n                      siteUrl: window.location.href,\n                      placeholders: domNodes.reduce(function (result, domNode) {\n                        var name = domNode.getAttribute(\'data-v\');\n\n                        if (name && name != "") {\n                          result.push(name);\n                        }\n\n                        return result;\n                      }, [])\n                    }\n                  }));\n                }\n              });\n              ws.addEventListener(\'message\', function (event) {\n                var data = event.data;\n                var dataParsed = JSON.parse(data);\n\n                if (dataParsed.action === \'setAnimationData\') {\n                  variojs.setAnimationData(dataParsed.payload);\n                }\n              });\n              ws.send(JSON.stringify({\n                action: \'pageReady\',\n                payload: {}\n              }));\n\n            case 7:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function init(_x) {\n      return _init.apply(this, arguments);\n    }\n\n    return init;\n  }()\n});\n\n//# sourceURL=webpack:///./src/lib.js_+_8_modules?')}])}));