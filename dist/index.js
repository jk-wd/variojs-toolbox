!function(n,i){if("object"==typeof exports&&"object"==typeof module)module.exports=i();else if("function"==typeof define&&define.amd)define([],i);else{var e=i();for(var a in e)("object"==typeof exports?exports:n)[a]=e[a]}}(window,(function(){return function(n){var i={};function e(a){if(i[a])return i[a].exports;var t=i[a]={i:a,l:!1,exports:{}};return n[a].call(t.exports,t,t.exports,e),t.l=!0,t.exports}return e.m=n,e.c=i,e.d=function(n,i,a){e.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:a})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,i){if(1&i&&(n=e(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var t in n)e.d(a,t,function(i){return n[i]}.bind(null,t));return a},e.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(i,"a",i),i},e.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},e.p="",e(e.s=3)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export numbers */\n/* unused harmony export animationDataNumbers */\n/* unused harmony export calculate */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return calculateSumString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEditNumberVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return setNumberVariables; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return deleteNumberVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getNumbers; });\n/* unused harmony export saveAnimationDataNumbers */\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\n\nvar numbers = {};\nvar animationDataNumbers = {};\nvar calculate = function calculate(numbers, sumString) {\n  var sumStringResult = "" + sumString;\n  var numberVarMatches = sumStringResult.match(/\\[([-a-zA-Z]*)\\]/g);\n\n  if (numberVarMatches && numberVarMatches.length > 0) {\n    for (var _i = 0, numberVarMatches_1 = numberVarMatches; _i < numberVarMatches_1.length; _i++) {\n      var numberVarIndex = numberVarMatches_1[_i];\n      var index = numberVarIndex.replace(\'[\', \'\').replace(\']\', \'\');\n\n      if (numberVarIndex && numbers[index]) {\n        var value = 0;\n        value = numbers[index];\n        sumStringResult = sumStringResult.replace(new RegExp("\\\\[" + index + "\\\\]", \'g\'), \'\' + value);\n      }\n    }\n  }\n\n  var result = 0;\n\n  try {\n    result = eval(sumStringResult) || 0;\n\n    if (typeof result !== \'number\') {\n      result = 0;\n    }\n  } catch (_a) {\n    result = 0;\n  }\n\n  return result;\n};\nvar calculateSumString = function calculateSumString(sumString, numbersParam, animationDataNumbersParam) {\n  if (numbersParam === void 0) {\n    numbersParam = numbers;\n  }\n\n  if (animationDataNumbersParam === void 0) {\n    animationDataNumbersParam = animationDataNumbers;\n  }\n\n  var localResult = calculate(numbersParam, sumString);\n  var animationDataResult = calculate(animationDataNumbersParam, sumString);\n\n  if (localResult) {\n    return localResult;\n  }\n\n  if (animationDataResult) {\n    return animationDataResult;\n  }\n\n  return 0;\n};\nvar addEditNumberVariable = function addEditNumberVariable(name, value, animationData) {\n  var _a, _b;\n\n  if (animationData === void 0) {\n    animationData = false;\n  }\n\n  if (typeof value !== \'number\') {\n    throw _errors__WEBPACK_IMPORTED_MODULE_0__[/* InvalidNumberVariableValueUsed */ "i"];\n  }\n\n  if (animationData) {\n    animationDataNumbers = __assign(__assign({}, numbers), (_a = {}, _a[name] = value, _a));\n    return;\n  }\n\n  numbers = __assign(__assign({}, numbers), (_b = {}, _b[name] = value, _b));\n};\nvar setNumberVariables = function setNumberVariables(numberVariables, animationData) {\n  if (numberVariables === void 0) {\n    numberVariables = {};\n  }\n\n  if (animationData === void 0) {\n    animationData = false;\n  }\n\n  if (animationData) {\n    animationDataNumbers = numberVariables;\n    return;\n  }\n\n  numbers = numberVariables;\n};\nvar deleteNumberVariable = function deleteNumberVariable(name, animationData) {\n  if (animationData === void 0) {\n    animationData = false;\n  }\n\n  if (animationData) {\n    delete animationDataNumbers[name];\n    return;\n  }\n\n  delete numbers[name];\n};\nvar getNumbers = function getNumbers() {\n  return numbers;\n};\nvar saveAnimationDataNumbers = function saveAnimationDataNumbers(animationData) {\n  return __assign(__assign({}, animationData), {\n    numbers: animationDataNumbers\n  });\n};\n\n//# sourceURL=webpack:///../variojs/lib/data/number-variables.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return AnimationDefinitionIdAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return AnimationDefinitionNameAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return AnimationEntryIdAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return AnimationEntryNameAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return FrameIdAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return BreakpointIdAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return TimelineIdAlreadyUsed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AnimationDefinitionForAnimationConnectionNotFound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return AnimationDefinitionNotFound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return InvalidNumberVariableValueUsed; });\nvar AnimationDefinitionIdAlreadyUsed = new Error('Animation definition id is already used');\nvar AnimationDefinitionNameAlreadyUsed = new Error('Animation definition name is already used');\nvar AnimationEntryIdAlreadyUsed = new Error('Animation entry id is already used');\nvar AnimationEntryNameAlreadyUsed = new Error('Animation entry name is already used');\nvar FrameIdAlreadyUsed = new Error('Frame id is already used');\nvar BreakpointIdAlreadyUsed = new Error('Breakpoint id is already used');\nvar TimelineIdAlreadyUsed = new Error('Timeline id is already used');\nvar AnimationDefinitionForAnimationConnectionNotFound = new Error('AnimationDefinition for animationConnection not found');\nvar AnimationDefinitionNotFound = new Error('animationDefinition not found');\nvar InvalidNumberVariableValueUsed = new Error('Invalid number variable type is used, only number or function allowed');\n\n//# sourceURL=webpack:///../variojs/lib/errors.js?")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function() {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/browser.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ../variojs/lib/types-interfaces.js\nvar PropTypes;\n\n(function (PropTypes) {\n  PropTypes["translateX"] = "translateX";\n  PropTypes["translateY"] = "translateY";\n  PropTypes["width"] = "width";\n  PropTypes["height"] = "height";\n  PropTypes["scaleX"] = "scaleX";\n  PropTypes["scaleY"] = "scaleY";\n  PropTypes["opacity"] = "opacity";\n  PropTypes["rotate"] = "rotate";\n  PropTypes["display"] = "display";\n  PropTypes["visibility"] = "visibility";\n})(PropTypes || (PropTypes = {}));\n\nvar NoBreakpointIdentifier = "none";\nvar Units;\n\n(function (Units) {\n  Units["percent"] = "%";\n  Units["px"] = "px";\n  Units["em"] = "em";\n  Units["rem"] = "rem";\n  Units["vw"] = "vw";\n  Units["vh"] = "vh";\n  Units["deg"] = "deg";\n})(Units || (Units = {}));\n\nvar FrameValueTypes;\n\n(function (FrameValueTypes) {\n  FrameValueTypes["string"] = "string";\n  FrameValueTypes["number"] = "number";\n})(FrameValueTypes || (FrameValueTypes = {}));\n// EXTERNAL MODULE: ../variojs/lib/data/number-variables.js\nvar number_variables = __webpack_require__(0);\n\n// CONCATENATED MODULE: ../variojs/lib/utils.js\nvar uuidv4 = function uuidv4() {\n  return \'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c == \'x\' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\nvar calculatePageScroll = function calculatePageScroll(startPos) {\n  if (startPos === void 0) {\n    startPos = 0;\n  }\n\n  var documentElement = document.documentElement || document.body;\n  var scrollHeight = documentElement.scrollHeight;\n  var scrollOffset = window.pageYOffset || documentElement.scrollTop;\n  var scrollOffsetMinStart = Math.max(scrollOffset - startPos, 0);\n  var percentage = scrollOffsetMinStart / (scrollHeight - documentElement.clientHeight);\n  var scrollPercentage = Math.min(Math.max(percentage, 0), 1) * 100;\n  return {\n    scrollOffset: scrollOffsetMinStart,\n    scrollPercentage: scrollPercentage\n  };\n};\n// EXTERNAL MODULE: ../variojs/lib/errors.js\nvar errors = __webpack_require__(1);\n\n// CONCATENATED MODULE: ../variojs/lib/data/breakpoints.js\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\nvar sortBreakpoints = function sortBreakpoints(breakpointA, breakpointB) {\n  if (breakpointA.order < breakpointB.order) {\n    return 1;\n  }\n\n  return -1;\n};\nvar breakpoints_getActiveBreakPoint = function getActiveBreakPoint(animationData) {\n  var result = NoBreakpointIdentifier;\n\n  if (!animationData || !animationData.breakpoints) {\n    return result;\n  }\n\n  for (var _i = 0, _a = animationData.breakpoints.sort(sortBreakpoints); _i < _a.length; _i++) {\n    var breakPointDefinition = _a[_i];\n\n    if (window.matchMedia(breakPointDefinition.definition).matches) {\n      result = breakPointDefinition.id;\n    }\n  }\n\n  return result;\n};\nvar breakpoints_addBreakpoint = function addBreakpoint(animationData, breakpoint) {\n  var breakpoints = animationData.breakpoints ? animationData.breakpoints : [];\n  var id = breakpoint.id ? breakpoint.id : uuidv4();\n\n  if (animationData.breakpoints && animationData.breakpoints.find(function (breakpoint) {\n    return breakpoint.id && breakpoint.id === id;\n  })) {\n    throw errors["g" /* BreakpointIdAlreadyUsed */];\n  }\n\n  return __assign(__assign({}, animationData), {\n    breakpoints: __spreadArrays(breakpoints, [__assign(__assign({}, breakpoint), {\n      id: id\n    })])\n  });\n};\nvar breakpoints_editBreakpoint = function editBreakpoint(animationData, breakpoint) {\n  var breakpoints = animationData.breakpoints ? animationData.breakpoints : [];\n\n  var animationDataResult = __assign(__assign({}, animationData), {\n    breakpoints: breakpoints.reduce(function (result, breakpointTarget) {\n      if (breakpoint.id === breakpointTarget.id) {\n        result.push(__assign(__assign({}, breakpointTarget), breakpoint));\n      } else {\n        result.push(breakpointTarget);\n      }\n\n      return result;\n    }, [])\n  });\n\n  return animationDataResult;\n};\nvar breakpoints_deleteBreakpoint = function deleteBreakpoint(animationData, breakpointId) {\n  var breakpoints = animationData.breakpoints ? animationData.breakpoints : [];\n\n  var animationDataResult = __assign(__assign({}, animationData), {\n    breakpoints: breakpoints.reduce(function (result, breakpoint) {\n      if (breakpoint.id !== breakpointId) {\n        result.push(breakpoint);\n      }\n\n      return result;\n    }, [])\n  });\n\n  return animationDataResult;\n};\n// CONCATENATED MODULE: ../variojs/lib/helpers/frame.js\n\n\n\nvar isFrameDefined = function isFrameDefined(frames, frame, pixelBased) {\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  var index = pixelBased ? \'px\' : \'ms\';\n  return frames.some(function (frameToCompare) {\n    return frameToCompare[index] !== undefined && frameToCompare[index] === frame[index];\n  });\n};\nvar getClosestFramesForTimeline = function getClosestFramesForTimeline(animation, timeline, key) {\n  var frames = animation.animationProps[key];\n  var frameUnitId = animation.pixelBased ? \'px\' : \'ms\';\n  var goal = timeline.progress || 0;\n  var closestsFrames = getClosestFrames(frames, goal, frameUnitId);\n  return {\n    closestsFrames: closestsFrames,\n    goal: goal,\n    frameUnitId: frameUnitId\n  };\n};\nvar getClosestFrames = function getClosestFrames(frames, goal, frameUnitId) {\n  var result = [];\n\n  for (var _i = 0, frames_1 = frames; _i < frames_1.length; _i++) {\n    var frame = frames_1[_i];\n    var value = frame[frameUnitId];\n\n    if (value <= goal) {\n      result[0] = frame;\n    }\n  }\n\n  for (var i = frames.length - 1; i >= 0; i--) {\n    var value = frames[i][frameUnitId];\n\n    if (value > goal) {\n      result[1] = frames[i];\n    }\n  }\n\n  if (!result[0]) {\n    result[0] = frames[0];\n  }\n\n  if (!result[1]) {\n    result[1] = result[0];\n  }\n\n  return result;\n};\nvar isFrameValid = function isFrameValid(frame) {\n  return frame.px || frame.ms || frame.ms === 0 || frame.px === 0;\n};\nvar sortFramesMs = function sortFramesMs(frameA, frameB) {\n  if ((frameA.ms || frameA.ms === 0) && (frameB.ms || frameB.ms === 0) && frameA.ms < frameB.ms) {\n    return -1;\n  }\n\n  return 1;\n};\nvar sortFramesPx = function sortFramesPx(frameA, frameB) {\n  if ((frameA.px || frameA.px === 0) && (frameB.px || frameB.px === 0) && frameA.px < frameB.px) {\n    return -1;\n  }\n\n  return 1;\n};\nvar frame_processFrameDef = function processFrameDef(animationData, frameDef, numbersParam, animationDataNumbersParam) {\n  var breakpoint = breakpoints_getActiveBreakPoint(animationData);\n  var frame = {\n    easing: frameDef.easing ? frameDef.easing : undefined,\n    unit: frameDef.unit ? frameDef.unit : undefined,\n    percent: frameDef.percentDef ? Object(number_variables["b" /* calculateSumString */])(frameDef.percentDef, numbersParam, animationDataNumbersParam) : undefined,\n    ms: frameDef.msDef ? Object(number_variables["b" /* calculateSumString */])(frameDef.msDef, numbersParam, animationDataNumbersParam) : undefined,\n    px: frameDef.pxDef ? Object(number_variables["b" /* calculateSumString */])(frameDef.pxDef, numbersParam, animationDataNumbersParam) : undefined\n  };\n  var frameValueIndex = frameDef.frameValueType === FrameValueTypes.number ? \'numberValue\' : \'stringValue\';\n\n  if (frameDef.valueDef) {\n    frame[frameValueIndex] = frameDef.frameValueType === FrameValueTypes.number ? Object(number_variables["b" /* calculateSumString */])(frameDef.valueDef[NoBreakpointIdentifier]) : frameDef.valueDef[NoBreakpointIdentifier];\n\n    for (var _i = 0, _a = Object.keys(frameDef.valueDef); _i < _a.length; _i++) {\n      var key = _a[_i];\n\n      if (key === breakpoint && frameDef.valueDef[key]) {\n        frame[frameValueIndex] = frameDef.frameValueType === FrameValueTypes.number ? Object(number_variables["b" /* calculateSumString */])(frameDef.valueDef[key]) : frameDef.valueDef[key];\n      }\n    }\n  }\n\n  return frame;\n};\n// CONCATENATED MODULE: ../variojs/lib/easing-functions.js\nvar EasingFunctions = {\n  linear: function linear(t) {\n    return t;\n  },\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  // @ts-ignore:\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  // @ts-ignore:\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  // @ts-ignore:\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  // @ts-ignore:\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n  // @ts-ignore:\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  // @ts-ignore:\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  // @ts-ignore:\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  // @ts-ignore:\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  // @ts-ignore:\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  // @ts-ignore:\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n  // @ts-ignore:\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  },\n  // @ts-ignore:\n  easeOutElastic: function easeOutElastic(t) {\n    return (.04 - .04 / t) * Math.sin(25 * t) + 1;\n  },\n  // @ts-ignore:\n  easeInElastic: function easeInElastic(t) {\n    return .04 * t / --t * Math.sin(25 * t);\n  },\n  // @ts-ignore:\n  easeInOutElastic: function easeInOutElastic(t) {\n    return (t -= .5) < 0 ? (.02 + .01 / t) * Math.sin(50 * t) : (.02 - .01 / t) * Math.sin(50 * t) + 1;\n  }\n};\n// CONCATENATED MODULE: ../variojs/lib/value-parsers.js\n\n\n\nvar value_parsers_parseStringFrames = function parseStringFrames(_a) {\n  var animation = _a.animation,\n      timeline = _a.timeline,\n      key = _a.key;\n  var closestsFrames = getClosestFramesForTimeline(animation, timeline, key).closestsFrames;\n\n  if (!closestsFrames[0]) {\n    return;\n  }\n\n  return closestsFrames[0].stringValue;\n};\nvar value_parsers_parseNumberFrames = function parseNumberFrames(_a) {\n  var animation = _a.animation,\n      timeline = _a.timeline,\n      key = _a.key;\n\n  var _b = getClosestFramesForTimeline(animation, timeline, key),\n      closestsFrames = _b.closestsFrames,\n      goal = _b.goal,\n      frameUnitId = _b.frameUnitId;\n\n  if (!closestsFrames[0]) {\n    return;\n  }\n\n  var startValue = closestsFrames[0].numberValue;\n  var startFrame = closestsFrames[0][frameUnitId];\n  var endValue = closestsFrames[1].numberValue;\n  var endFrame = closestsFrames[1][frameUnitId];\n\n  if (!startValue && startValue != 0 || !startFrame && startFrame != 0 || !endValue && endValue != 0 || !endFrame && endFrame != 0) {\n    return;\n  }\n\n  var easingFunction = closestsFrames[1].easing ? EasingFunctions[closestsFrames[1].easing] : EasingFunctions.linear;\n  var factor = easingFunction((goal - startFrame) / (endFrame - startFrame));\n  factor = !isNaN(factor) ? Math.min(Math.max(factor, 0), 1) : 0;\n  var value = startValue + (endValue - startValue) * factor;\n  var devideBy = key === PropTypes.scaleX || key === PropTypes.scaleY || key === PropTypes.opacity ? 100 : 1;\n  var unit = key === PropTypes.scaleX || key === PropTypes.scaleY || key === PropTypes.rotate || key === PropTypes.opacity ? \'\' : closestsFrames[1].unit;\n  return "" + value / devideBy + (unit || \'\');\n};\nvar parserMap = {\n  translateX: value_parsers_parseNumberFrames,\n  translateY: value_parsers_parseNumberFrames,\n  width: value_parsers_parseNumberFrames,\n  height: value_parsers_parseNumberFrames,\n  scaleX: value_parsers_parseNumberFrames,\n  scaleY: value_parsers_parseNumberFrames,\n  rotate: value_parsers_parseNumberFrames,\n  opacity: value_parsers_parseNumberFrames,\n  display: value_parsers_parseStringFrames,\n  visibility: value_parsers_parseStringFrames\n};\n/* harmony default export */ var value_parsers = (parserMap);\n// CONCATENATED MODULE: ../variojs/lib/styling-parsers.js\nvar applyStyling = function applyStyling(domElements, key, value) {\n  for (var _i = 0, domElements_1 = domElements; _i < domElements_1.length; _i++) {\n    var domElement = domElements_1[_i];\n    domElement.style[key] = value;\n  }\n};\nvar domStylingParser = function domStylingParser(element) {\n  var transforms = [];\n\n  if (!element) {\n    return;\n  }\n\n  var stylingValues = element.stylingValues;\n\n  if (stylingValues.display) {\n    applyStyling(element.domElements, \'display\', "" + stylingValues.display);\n  }\n\n  if (stylingValues.visibility) {\n    applyStyling(element.domElements, \'visibility\', "" + stylingValues.visibility);\n  }\n\n  if (stylingValues.display === "none" || stylingValues.visibility === "hidden") {\n    return;\n  }\n\n  if (stylingValues.opacity) {\n    applyStyling(element.domElements, \'opacity\', "" + stylingValues.opacity);\n  }\n\n  if (parseFloat(stylingValues.opacity) <= 0) {\n    return;\n  }\n\n  if (stylingValues.translateX || stylingValues.translateY) {\n    transforms.push("translate3d(" + (stylingValues.translateX || 0) + ", " + (stylingValues.translateY || 0) + ", 0)");\n  }\n\n  if (stylingValues.scaleX || stylingValues.scaleY) {\n    transforms.push("scale3d(" + (stylingValues.scaleX || 1) + ", " + (stylingValues.scaleY || 1) + ", 1)");\n  }\n\n  if (stylingValues.width) {\n    applyStyling(element.domElements, \'width\', "" + stylingValues.width);\n  }\n\n  if (stylingValues.height) {\n    applyStyling(element.domElements, \'height\', "" + stylingValues.height);\n  }\n\n  if (stylingValues.rotate) {\n    transforms.push("rotate(" + (stylingValues.rotate || 0) + "deg)");\n  }\n\n  if (transforms.length > 0) {\n    applyStyling(element.domElements, \'transform\', transforms.join(" "));\n  }\n};\n// CONCATENATED MODULE: ../variojs/lib/data/animationDefinition.js\nvar animationDefinition_assign = undefined && undefined.__assign || function () {\n  animationDefinition_assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return animationDefinition_assign.apply(this, arguments);\n};\n\nvar animationDefinition_spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\nvar getAnimationDefinitionsByIds = function getAnimationDefinitionsByIds(animationData, ids) {\n  if (!ids) {\n    return [];\n  }\n\n  var animationDefinitions = animationData.animationDefinitions ? animationData.animationDefinitions : [];\n  return ids.reduce(function (result, id) {\n    var animationDefinition = animationDefinitions.find(function (animationDefinition) {\n      return id === animationDefinition.id;\n    });\n\n    if (animationDefinition) {\n      result.push(animationDefinition);\n    }\n\n    return result;\n  }, []);\n};\nvar animationDefinition_getAnimationDefinitionById = function getAnimationDefinitionById(animationData, id) {\n  var animationDefinitions = animationData.animationDefinitions ? animationData.animationDefinitions : [];\n  return animationDefinitions.find(function (animationDefinition) {\n    return id && animationDefinition.id === id ? true : false;\n  });\n};\n\nvar animationDefinition_makeAnimationDefinitionGlobal = function makeAnimationDefinitionGlobal(animationData, animationDefinition) {\n  var entries = animationData.animationEntries ? animationData.animationEntries : [];\n  var newAnimationDefinition;\n\n  var animationDataResult = animationDefinition_assign(animationDefinition_assign({}, animationData), {\n    animationEntries: entries.map(function (animationEntry) {\n      if (animationEntry.animationConnection && animationEntry.animationConnection.animationDefinitionId === animationDefinition.id && animationDefinition.name) {\n        newAnimationDefinition = {\n          id: uuidv4(),\n          props: {}\n        };\n        return animationDefinition_assign(animationDefinition_assign({}, animationEntry), {\n          animationConnection: {\n            animationDefinitionId: newAnimationDefinition.id\n          },\n          animationConnections: animationDefinition_spreadArrays(animationEntry.animationConnections || [], [{\n            animationDefinitionId: animationDefinition.id\n          }]).reduce(function (result, animationConnection) {\n            if (!result.find(function (animationConnectionFind) {\n              return animationConnectionFind.animationDefinitionId === animationConnection.animationDefinitionId;\n            })) {\n              result.push(animationConnection);\n            }\n\n            return result;\n          }, [])\n        });\n      } else {\n        return animationEntry;\n      }\n    })\n  });\n\n  if (newAnimationDefinition) {\n    var newAnimationData = animationDefinition_addAnimationDefinition(animationDataResult, newAnimationDefinition);\n\n    if (newAnimationData) {\n      return newAnimationData;\n    }\n\n    return animationDataResult;\n  }\n\n  return animationDataResult;\n};\n\nvar animationDefinition_editAnimationDefinition = function editAnimationDefinition(animationData, animationDefinition) {\n  var definitions = animationData.animationDefinitions ? animationData.animationDefinitions : [];\n  var result = undefined;\n  var animationDefinitions = definitions.map(function (animationDefinitionTarget) {\n    if (animationDefinitionTarget.id === animationDefinition.id) {\n      result = animationDefinition_assign(animationDefinition_assign({}, animationDefinitionTarget), animationDefinition);\n      return result;\n    }\n\n    return animationDefinitionTarget;\n  });\n\n  if (result && result.name) {\n    return animationDefinition_makeAnimationDefinitionGlobal(animationDefinition_assign(animationDefinition_assign({}, animationData), {\n      animationDefinitions: animationDefinitions\n    }), result);\n  }\n\n  return animationDefinition_assign(animationDefinition_assign({}, animationData), {\n    animationDefinitions: animationDefinitions\n  });\n};\nvar animationDefinition_addAnimationDefinition = function addAnimationDefinition(animationData, animationDefinition) {\n  var definitions = animationData.animationDefinitions ? animationData.animationDefinitions : [];\n  var id = animationDefinition.id ? animationDefinition.id : uuidv4();\n\n  if (animationData.animationDefinitions && animationData.animationDefinitions.find(function (definition) {\n    return definition.id && definition.id === id;\n  })) {\n    throw errors["b" /* AnimationDefinitionIdAlreadyUsed */];\n  }\n\n  if (animationData.animationDefinitions && animationData.animationDefinitions.find(function (definition) {\n    return definition.name && definition.name === animationDefinition.name;\n  })) {\n    throw errors["c" /* AnimationDefinitionNameAlreadyUsed */];\n  }\n\n  return animationDefinition_assign(animationDefinition_assign({}, animationData), {\n    animationDefinitions: animationDefinition_spreadArrays(definitions, [animationDefinition_assign(animationDefinition_assign({}, animationDefinition), {\n      id: id\n    })])\n  });\n};\nvar animationDefinition_deleteAnimationDefinition = function deleteAnimationDefinition(animationData, animationDefinitionId) {\n  var animationDefinitions = animationData.animationDefinitions ? animationData.animationDefinitions : [];\n  return animationDefinition_assign(animationDefinition_assign({}, animationData), {\n    animationDefinitions: animationDefinitions.reduce(function (result, animation) {\n      if (animation.id != animationDefinitionId) {\n        result.push(animation);\n      }\n\n      return result;\n    }, [])\n  });\n};\n// CONCATENATED MODULE: ../variojs/lib/helpers/animationProps.js\n\n\n\n\nvar animationProps_mergeAnimations = function mergeAnimations(animation, animationToMerge, pixelBased) {\n  if (animationToMerge === void 0) {\n    animationToMerge = {};\n  }\n\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  var result = Object.keys(animation).length > 0 ? mergeAnimations({}, animation, pixelBased) : {};\n\n  for (var propKey in animationToMerge) {\n    if (!result[propKey]) {\n      result[propKey] = [];\n    }\n\n    var propToMerge = animationToMerge[propKey] ? animationToMerge[propKey] : [];\n\n    for (var _i = 0, propToMerge_1 = propToMerge; _i < propToMerge_1.length; _i++) {\n      var frame = propToMerge_1[_i];\n\n      if (isFrameValid(frame) && !isFrameDefined(result[propKey], frame, pixelBased)) {\n        result[propKey].push(frame);\n      } else if (frame.percent || frame.percent === 0) {\n        result[propKey].push(frame);\n      }\n    }\n\n    var sortFunc = pixelBased ? sortFramesPx : sortFramesMs;\n    result[propKey] = result[propKey].sort(sortFunc);\n  }\n\n  return result;\n};\nvar getEndFromAnimationProps = function getEndFromAnimationProps(animationProps, pixelBased) {\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  var result = 0;\n  var unitIndex = pixelBased ? \'px\' : \'ms\';\n\n  for (var _i = 0, _a = Object.keys(animationProps); _i < _a.length; _i++) {\n    var propKey = _a[_i];\n    var prop = animationProps[propKey];\n\n    if (prop && prop.constructor === Array) {\n      for (var _b = 0, prop_1 = prop; _b < prop_1.length; _b++) {\n        var frame = prop_1[_b];\n\n        if (frame[unitIndex]) {\n          result = Math.max(frame[unitIndex], result);\n        }\n      }\n    } else if (prop && prop[unitIndex]) {\n      result = Math.max(prop[unitIndex], result);\n    }\n  }\n\n  return result;\n};\nvar animationProps_processAnimationProps = function processAnimationProps(animationData, animationProps) {\n  var changedProps = {};\n\n  for (var _i = 0, _a = Object.keys(animationProps); _i < _a.length; _i++) {\n    var propKey = _a[_i];\n    changedProps[propKey] = animationProps[propKey].reduce(function (result, frameDef) {\n      if (frameDef) {\n        var frame = frame_processFrameDef(animationData, frameDef);\n        result.push(frame);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return changedProps;\n};\nvar animationProps_processFrameStart = function processFrameStart(animationProps, animationConnection) {\n  if (!animationConnection) {\n    return animationProps;\n  }\n\n  var result = JSON.parse(JSON.stringify(animationProps));\n\n  for (var propKey in result) {\n    for (var _i = 0, _a = result[propKey]; _i < _a.length; _i++) {\n      var frame = _a[_i];\n      frame.startMs = Object(number_variables["b" /* calculateSumString */])(animationConnection.startMs || \'\');\n      frame.startPx = Object(number_variables["b" /* calculateSumString */])(animationConnection.startPx || \'\');\n      frame.px = frame.px + frame.startPx;\n      frame.ms = frame.ms + frame.startMs;\n    }\n  }\n\n  return result;\n};\nvar animationProps_processAnimationConnections = function processAnimationConnections(animationData, animationConnections, pixelBased) {\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  if (!animationData) {\n    return {};\n  }\n\n  var animation = {};\n\n  for (var _i = 0, _a = animationConnections || []; _i < _a.length; _i++) {\n    var animationConnection = _a[_i];\n\n    if (!animationConnection) {\n      continue;\n    }\n\n    var animationDefinition = animationDefinition_getAnimationDefinitionById(animationData, animationConnection.animationDefinitionId);\n\n    if (animationDefinition) {\n      var animationProps = animationProps_processAnimationProps(animationData, animationDefinition.props);\n      animationProps = animationProps_processFrameStart(animationProps, animationConnection);\n      animation = animationProps_mergeAnimations(animationProps, animation, pixelBased);\n    }\n  }\n\n  return animation;\n};\n// CONCATENATED MODULE: ../variojs/lib/data/animationEntry.js\nvar animationEntry_assign = undefined && undefined.__assign || function () {\n  animationEntry_assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return animationEntry_assign.apply(this, arguments);\n};\n\nvar animationEntry_spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\nvar animationEntry_getAnimationEntryById = function getAnimationEntryById(animationData, id) {\n  return animationData.animationEntries ? animationData.animationEntries.find(function (entry) {\n    return entry.id === id;\n  }) : undefined;\n};\nvar animationEntry_editAnimationEntry = function editAnimationEntry(animationData, animationEntry) {\n  var entries = animationData.animationEntries ? animationData.animationEntries : [];\n\n  var animationDataResult = animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: entries.reduce(function (result, entry) {\n      if (entry.id === animationEntry.id) {\n        result.push(animationEntry_assign(animationEntry_assign({}, entry), animationEntry));\n      } else {\n        result.push(entry);\n      }\n\n      return result;\n    }, [])\n  });\n\n  return animationDataResult;\n};\nvar animationEntry_addAnimationEntry = function addAnimationEntry(animationData, animationEntry) {\n  var entries = animationData.animationEntries ? animationData.animationEntries : [];\n  var id = animationEntry.id ? animationEntry.id : uuidv4();\n\n  if (animationData.animationEntries && animationData.animationEntries.find(function (entry) {\n    return entry.id && entry.id === id;\n  })) {\n    throw errors["e" /* AnimationEntryIdAlreadyUsed */];\n  }\n\n  if (animationData.animationEntries && animationData.animationEntries.find(function (entry) {\n    return entry.name && entry.name === animationEntry.name;\n  })) {\n    throw errors["f" /* AnimationEntryNameAlreadyUsed */];\n  }\n\n  var animationDataResult = animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: animationEntry_spreadArrays(entries, [animationEntry_assign(animationEntry_assign({}, animationEntry), {\n      id: id\n    })])\n  });\n\n  return animationDataResult;\n};\nvar animationEntry_deleteAnimationEntry = function deleteAnimationEntry(animationData, animationEntryId) {\n  var animationEntries = animationData.animationEntries ? animationData.animationEntries : [];\n  var definitionId;\n\n  var animationDataResult = animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: animationEntries.reduce(function (result, animation) {\n      if (animation.id != animationEntryId) {\n        result.push(animation);\n      } else if (animation.animationConnection) {\n        definitionId = animation.animationConnection.animationDefinitionId;\n      }\n\n      return result;\n    }, [])\n  });\n\n  if (definitionId) {\n    return animationDefinition_deleteAnimationDefinition(animationDataResult, definitionId);\n  }\n\n  return animationDataResult;\n};\nvar animationEntry_deleteAnimationEntryConnection = function deleteAnimationEntryConnection(animationData, animationEntryId, animationDefinitionId, local) {\n  if (local === void 0) {\n    local = false;\n  }\n\n  return animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: animationData.animationEntries ? animationData.animationEntries.map(function (animationEntry) {\n      var connections = animationEntry.animationConnections ? animationEntry.animationConnections : [];\n\n      if (animationEntry.id === animationEntryId) {\n        if (local) {\n          delete animationEntry.animationConnection;\n          return animationEntry_assign({}, animationEntry);\n        }\n\n        return animationEntry_assign(animationEntry_assign({}, animationEntry), {\n          animationConnections: connections.reduce(function (result, connection) {\n            if (connection.animationDefinitionId != animationDefinitionId) {\n              result.push(connection);\n            }\n\n            return result;\n          }, [])\n        });\n      }\n\n      return animationEntry;\n    }) : []\n  });\n};\nvar animationEntry_addAnimationEntryConnection = function addAnimationEntryConnection(animationData, animationEntryId, animationConnection, local) {\n  if (local === void 0) {\n    local = false;\n  }\n\n  if (!animationData.animationDefinitions || !animationData.animationDefinitions.find(function (animationDefinition) {\n    return animationDefinition.id === animationConnection.animationDefinitionId;\n  })) {\n    throw errors["a" /* AnimationDefinitionForAnimationConnectionNotFound */];\n  }\n\n  return animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: animationData.animationEntries ? animationData.animationEntries.map(function (animationEntry) {\n      if (animationEntry.id === animationEntryId) {\n        if (local) {\n          return animationEntry_assign(animationEntry_assign({}, animationEntry), {\n            animationConnection: animationConnection\n          });\n        }\n\n        var connections = animationEntry.animationConnections ? animationEntry_spreadArrays(animationEntry.animationConnections) : [];\n\n        if (!connections.find(function (connection) {\n          return connection.animationDefinitionId === animationConnection.animationDefinitionId;\n        })) {\n          connections.push(animationConnection);\n        }\n\n        return animationEntry_assign(animationEntry_assign({}, animationEntry), {\n          animationConnections: connections\n        });\n      }\n\n      return animationEntry;\n    }) : []\n  });\n};\nvar animationEntry_editAnimationEntryConnection = function editAnimationEntryConnection(animationData, animationEntryId, animationConnection, local) {\n  if (local === void 0) {\n    local = false;\n  }\n\n  return animationEntry_assign(animationEntry_assign({}, animationData), {\n    animationEntries: animationData.animationEntries ? animationData.animationEntries.map(function (animationEntry) {\n      var connections = animationEntry.animationConnections ? animationEntry.animationConnections : [];\n\n      if (animationEntry.id === animationEntryId) {\n        if (local) {\n          return animationEntry_assign(animationEntry_assign({}, animationEntry), {\n            animationConnection: animationConnection\n          });\n        }\n\n        return animationEntry_assign(animationEntry_assign({}, animationEntry), {\n          animationConnections: connections.reduce(function (result, connectionTarget) {\n            if (connectionTarget.animationDefinitionId === animationConnection.animationDefinitionId) {\n              result.push(animationConnection);\n            } else {\n              result.push(connectionTarget);\n            }\n\n            return result;\n          }, [])\n        });\n      }\n\n      return animationEntry;\n    }) : []\n  });\n};\n// CONCATENATED MODULE: ../variojs/lib/data/timeline.js\nvar timeline_assign = undefined && undefined.__assign || function () {\n  timeline_assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return timeline_assign.apply(this, arguments);\n};\n\nvar timeline_spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\n\n\n\nvar timeline_getTimelineById = function getTimelineById(animationData, id) {\n  return (animationData.timelines || []).find(function (timeline) {\n    return timeline.id === id;\n  });\n};\nvar timeline_getTimelineDuration = function getTimelineDuration(animationData, timelineId) {\n  var result = 0;\n  var timeline = timeline_getTimelineById(animationData, timelineId);\n\n  if (!timeline) {\n    return result;\n  }\n\n  if (timeline.duration) {\n    return Object(number_variables["b" /* calculateSumString */])(timeline.duration);\n  }\n\n  for (var _i = 0, _a = timeline.animationEntries || []; _i < _a.length; _i++) {\n    var animationEntryId = _a[_i];\n    var animationEntry = animationEntry_getAnimationEntryById(animationData, animationEntryId);\n\n    if (!animationEntry) {\n      continue;\n    }\n\n    var animationConnections = timeline_spreadArrays(animationEntry.animationConnections ? animationEntry.animationConnections : [], [animationEntry.animationConnection]);\n\n    if (animationConnections && animationConnections.length > 0) {\n      var animationProps = animationProps_processAnimationConnections(animationData, animationConnections, timeline.pixelBased);\n      result = Math.max(getEndFromAnimationProps(animationProps, timeline.pixelBased), result);\n    }\n  }\n\n  return result;\n};\nvar timeline_addTimeline = function addTimeline(animationData, timeline) {\n  animationData.timelines = animationData.timelines ? animationData.timelines : [];\n  var id = timeline.id ? timeline.id : uuidv4();\n\n  if (animationData.timelines && animationData.timelines.find(function (timeline) {\n    return timeline.id && timeline.id === id;\n  })) {\n    throw errors["j" /* TimelineIdAlreadyUsed */];\n  }\n\n  return timeline_assign(timeline_assign({}, animationData), {\n    timelines: timeline_spreadArrays(animationData.timelines, [timeline_assign(timeline_assign({}, timeline), {\n      id: id\n    })])\n  });\n};\nvar timeline_editTimeline = function editTimeline(animationData, timeline) {\n  var timelines = animationData.timelines ? animationData.timelines : [];\n\n  var animationDataResult = timeline_assign(timeline_assign({}, animationData), {\n    timelines: timelines.reduce(function (result, timelineEntry) {\n      if (timelineEntry.id === timeline.id) {\n        result.push(timeline_assign(timeline_assign({}, timelineEntry), timeline));\n      } else {\n        result.push(timelineEntry);\n      }\n\n      return result;\n    }, [])\n  });\n\n  return animationDataResult;\n};\nvar timeline_deleteTimeline = function deleteTimeline(animationData, id) {\n  var timelines = animationData.timelines ? animationData.timelines : [];\n  var entries = [];\n\n  var animationDataResult = timeline_assign(timeline_assign({}, animationData), {\n    timelines: timelines.reduce(function (result, timeline) {\n      if (timeline.id !== id) {\n        result.push(timeline);\n      } else {\n        entries = timeline_spreadArrays(entries, timeline.animationEntries || []);\n      }\n\n      return result;\n    }, [])\n  });\n\n  if (entries.length > 0) {\n    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n      var entry = entries_1[_i];\n      animationDataResult = animationEntry_deleteAnimationEntry(animationDataResult, entry);\n    }\n  }\n\n  return animationDataResult;\n};\nvar timeline_connectTimelineAnimationEntry = function connectTimelineAnimationEntry(animationData, timelineId, entryId) {\n  var timelines = animationData.timelines ? animationData.timelines : [];\n  return timeline_assign(timeline_assign({}, animationData), {\n    timelines: timelines ? timelines.map(function (timeline) {\n      if (timeline.id === timelineId) {\n        var entries = timeline && timeline.animationEntries ? timeline.animationEntries : [];\n        return timeline_assign(timeline_assign({}, timeline), {\n          animationEntries: entries.indexOf(entryId) <= -1 ? timeline_spreadArrays(entries, [entryId]) : entries\n        });\n      }\n\n      return timeline;\n    }) : []\n  });\n};\nvar timeline_disconnectTimelineAnimationEntry = function disconnectTimelineAnimationEntry(animationData, timelineId, entryId) {\n  var timelines = animationData.timelines ? animationData.timelines : [];\n  return timeline_assign(timeline_assign({}, animationData), {\n    timelines: timelines.map(function (timeline) {\n      if (timeline.id === timelineId) {\n        var entries = timeline && timeline.animationEntries ? timeline.animationEntries : [];\n        return timeline_assign(timeline_assign({}, timeline), {\n          animationEntries: entries.reduce(function (result, entry) {\n            if (entryId != entry) {\n              result.push(entry);\n            }\n\n            return result;\n          }, [])\n        });\n      }\n\n      return timeline;\n    })\n  });\n};\n// CONCATENATED MODULE: ../variojs/lib/core.js\nvar core_assign = undefined && undefined.__assign || function () {\n  core_assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return core_assign.apply(this, arguments);\n};\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    "throw": verb(1),\n    "return": verb(2)\n  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError("Generator is already executing.");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar core_spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar core_animations = [];\nvar core_elements = {};\nvar options;\nvar animationFrameId;\nvar core_animationData;\nvar onUpdateAnimationDataCallback;\nvar activeBreakpoint = NoBreakpointIdentifier;\nvar timelineStates = {};\nvar pixelTimelineStates = {};\n\nvar updateTimelines = function updateTimelines(timestamp) {\n  if (!core_animationData.timelines) {\n    return;\n  }\n\n  for (var _i = 0, _a = core_animationData.timelines; _i < _a.length; _i++) {\n    var timeline = _a[_i];\n\n    if (timeline.pixelBased) {\n      continue;\n    }\n\n    timelineStates[timeline.id] = timelineStates[timeline.id] ? timelineStates[timeline.id] : {\n      id: timeline.id\n    };\n    var timelineState = timelineStates[timeline.id];\n\n    if (timelineState.isRunning && !timelineState.pause) {\n      if (!timelineState.start) timelineState.start = timestamp;\n      var pauseTime = timelineState.pauseTime ? timelineState.pauseTime : 0;\n      timelineState.progress = timestamp - timelineState.start - pauseTime;\n\n      if (timelineState.duration && timelineState.progress >= timelineState.duration) {\n        timelineState.start = timestamp - pauseTime;\n\n        if (!timeline.loop) {\n          timelineState.isRunning = false;\n        }\n      }\n    } else if (timelineState.isRunning && timelineState.pause && timelineState.progress) {\n      if (!timelineState.start) timelineState.start = timestamp;\n      timelineState.pauseTime = timestamp - timelineState.start - timelineState.progress;\n    }\n  }\n};\n\nvar core_updatePixelTimelines = function updatePixelTimelines() {\n  if (!core_animationData || !core_animationData.timelines) {\n    return;\n  }\n\n  var scrollOffset = calculatePageScroll().scrollOffset;\n\n  for (var _i = 0, _a = core_animationData.timelines; _i < _a.length; _i++) {\n    var timeline = _a[_i];\n\n    if (!timeline.pixelBased) {\n      continue;\n    }\n\n    pixelTimelineStates[timeline.id] = pixelTimelineStates[timeline.id] ? pixelTimelineStates[timeline.id] : {\n      id: timeline.id\n    };\n    var timelineState = pixelTimelineStates[timeline.id];\n\n    if (timeline.loop) {\n      var loopCount = timelineState.loopCount ? timelineState.loopCount : 0;\n      var end = timelineState.duration ? timelineState.duration : 0;\n      timelineState.progress = scrollOffset - end * loopCount;\n\n      if (timelineState.progress >= end) {\n        timelineState.loopCount = loopCount + 1;\n      }\n\n      if (timelineState.progress <= 0) {\n        timelineState.loopCount = loopCount - 1;\n      }\n    } else {\n      timelineState.progress = timelineState.duration ? Math.min(scrollOffset, timelineState.duration) : scrollOffset;\n    }\n  }\n};\n\nvar core_updateAnimations = function updateAnimations(animations) {\n  if (animations === void 0) {\n    animations = [];\n  }\n\n  for (var i = 0; i < animations.length; i++) {\n    var animation = animations[i];\n\n    for (var _i = 0, _a = Object.keys(animation.animationProps); _i < _a.length; _i++) {\n      var animationKey = _a[_i];\n      var parser = value_parsers[animationKey];\n      var timeline = animation.pixelBased ? pixelTimelineStates[animation.timelineId] : timelineStates[animation.timelineId];\n\n      if (parser && timeline && core_elements[animation.domReference]) {\n        core_elements[animation.domReference].stylingValues[animationKey] = parser({\n          animation: animation,\n          key: animationKey,\n          timeline: timeline\n        });\n      }\n    }\n  }\n};\n\nvar core_updateElements = function updateElements() {\n  for (var _i = 0, _a = Object.keys(core_elements); _i < _a.length; _i++) {\n    var elementKey = _a[_i];\n    var element = core_elements[elementKey];\n\n    if (typeof window !== \'undefined\') {\n      domStylingParser(element);\n    }\n  }\n};\n\nvar core_fillElementsArray = function fillElementsArray(animationEntries) {\n  var _loop_1 = function _loop_1(animationEntryId) {\n    var animationEntry = animationEntry_getAnimationEntryById(core_animationData, animationEntryId);\n\n    if (!animationEntry) {\n      return "continue";\n    }\n\n    var domElements = [];\n    var domElementsResult = document.querySelectorAll("[data-v=" + animationEntry.domReference + "]");\n    domElementsResult.forEach(function (domElement) {\n      domElements.push(domElement);\n    });\n\n    if (!domElements || domElements.length <= 0) {\n      return "continue";\n    }\n\n    core_elements[animationEntry.domReference] = {\n      domElements: domElements,\n      stylingValues: {}\n    };\n  };\n\n  for (var _i = 0, _a = animationEntries || []; _i < _a.length; _i++) {\n    var animationEntryId = _a[_i];\n\n    _loop_1(animationEntryId);\n  }\n};\n\nvar core_prepareTimelinState = function prepareTimelinState(animation) {\n  var timeline = timeline_getTimelineById(core_animationData, animation.timelineId);\n\n  if (!timeline) {\n    return;\n  }\n\n  if (!timeline.pixelBased) {\n    timelineStates[timeline.id] = timelineStates[timeline.id] ? timelineStates[timeline.id] : {\n      id: timeline.id\n    };\n  } else {\n    pixelTimelineStates[timeline.id] = pixelTimelineStates[timeline.id] ? pixelTimelineStates[timeline.id] : {\n      id: timeline.id\n    };\n  }\n\n  var timelineState = timeline.pixelBased ? pixelTimelineStates[timeline.id] : timelineStates[timeline.id];\n\n  if (timelineState) {\n    if (timeline.duration) {\n      timelineState.duration = Object(number_variables["b" /* calculateSumString */])(timeline.duration);\n      return;\n    }\n\n    var end = timelineState.duration ? timelineState.duration : 0;\n    timelineState.duration = Math.max(getEndFromAnimationProps(animation.animationProps, timeline.pixelBased), end);\n  }\n};\n\nvar core_updateExistingAnimations = function updateExistingAnimations(animation, pixelBased) {\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  var isUpdated = false;\n  core_animations = core_animations.reduce(function (result, animationDef) {\n    if (animationDef.pixelBased === animation.pixelBased && animationDef.domReference === animation.domReference && animationDef.timelineId === animation.timelineId) {\n      result.push(core_assign(core_assign({}, animationDef), {\n        animationProps: animationProps_mergeAnimations(animationDef.animationProps, animation.animationProps, pixelBased)\n      }));\n      isUpdated = true;\n    } else {\n      result.push(animationDef);\n    }\n\n    return result;\n  }, []);\n  return isUpdated;\n};\n\nvar core_processTimelineEntries = function processTimelineEntries(entries, timeline, pixelBased) {\n  if (pixelBased === void 0) {\n    pixelBased = false;\n  }\n\n  for (var _i = 0, _a = entries || []; _i < _a.length; _i++) {\n    var animationEntryId = _a[_i];\n    var animationEntry = animationEntry_getAnimationEntryById(core_animationData, animationEntryId);\n\n    if (!animationEntry) {\n      continue;\n    }\n\n    var animationProps = {};\n    var animationConnections = animationEntry.animationConnections ? animationEntry.animationConnections : [];\n    animationProps = animationProps_processAnimationConnections(core_animationData, core_spreadArrays(animationConnections, [animationEntry.animationConnection]), pixelBased);\n    var animation = {\n      domReference: animationEntry.domReference,\n      timelineId: timeline.id,\n      pixelBased: pixelBased,\n      animationProps: animationProps\n    };\n    core_prepareTimelinState(animation);\n\n    if (!core_updateExistingAnimations(animation, timeline.pixelBased)) {\n      core_animations.push(animation);\n    }\n  }\n};\n\nvar processTimelines = function processTimelines() {\n  if (!core_animationData || !core_animationData.timelines) {\n    return;\n  }\n\n  for (var _i = 0, _a = core_animationData.timelines; _i < _a.length; _i++) {\n    var timeline = _a[_i];\n\n    if (timeline.animationEntries) {\n      core_fillElementsArray(timeline.animationEntries);\n      core_processTimelineEntries(timeline.animationEntries, timeline, timeline.pixelBased);\n    }\n  }\n};\n\nvar loopUpdateAnimations = function loopUpdateAnimations(timestamp) {\n  core_updateAnimations(core_animations);\n  updateTimelines(timestamp);\n  core_updateElements();\n  core_updatePixelTimelines();\n  requestAnimationFrame(loopUpdateAnimations);\n};\n\nvar fetchAnimationJSON = function fetchAnimationJSON() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var result;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!options.url) {\n            return [2\n            /*return*/\n            ];\n          }\n\n          return [4\n          /*yield*/\n          , window.fetch(options.url)];\n\n        case 1:\n          result = _a.sent();\n          return [4\n          /*yield*/\n          , result.json()];\n\n        case 2:\n          return [2\n          /*return*/\n          , _a.sent()];\n      }\n    });\n  });\n};\n\nvar core_setupBreakpointHandler = function setupBreakpointHandler() {\n  activeBreakpoint = breakpoints_getActiveBreakPoint(core_animationData);\n  window.addEventListener("resize", function () {\n    var newActiveBreakpoint = breakpoints_getActiveBreakPoint(core_animationData);\n\n    if (newActiveBreakpoint !== activeBreakpoint) {\n      activeBreakpoint = newActiveBreakpoint;\n      core_elements = {};\n      core_animations = [];\n      processAnimationData();\n    }\n  });\n};\n\nvar play = function play(timelineId) {\n  var timelineTarget = timelineId ? timelineId : \'main\';\n  var timeline = timelineStates[timelineTarget];\n\n  if (timeline) {\n    timeline.pause = false;\n    timeline.isRunning = true;\n  }\n};\nvar pause = function pause(timelineId) {\n  var timelineTarget = timelineId ? timelineId : \'main\';\n  var timeline = timelineStates[timelineTarget];\n\n  if (timeline) {\n    timeline.pause = true;\n  }\n};\nvar core_init = function init(optionsParam) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var animationDataFetch;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          options = core_assign({}, optionsParam);\n          return [4\n          /*yield*/\n          , fetchAnimationJSON()];\n\n        case 1:\n          animationDataFetch = _a.sent();\n\n          if (animationDataFetch) {\n            core_animationData = animationDataFetch;\n\n            if (core_animationData.numbers) {\n              Object(number_variables["e" /* setNumberVariables */])(core_animationData.numbers, true);\n            }\n          }\n\n          processAnimationData();\n          requestAnimationFrame(loopUpdateAnimations);\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\nvar resetTimelineStateEnds = function resetTimelineStateEnds(timelineStates) {\n  var result = {};\n\n  for (var _i = 0, _a = Object.keys(timelineStates); _i < _a.length; _i++) {\n    var key = _a[_i];\n    result[key] = core_assign(core_assign({}, timelineStates[key]), {\n      duration: 0\n    });\n  }\n\n  return result;\n};\nvar processProcentueelValues = function processProcentueelValues() {\n  for (var _i = 0, animations_1 = core_animations; _i < animations_1.length; _i++) {\n    var animation = animations_1[_i];\n\n    if (!animation) {\n      continue;\n    }\n\n    for (var prop in animation.animationProps) {\n      if (!prop) {\n        continue;\n      }\n\n      for (var _a = 0, _b = animation.animationProps[prop]; _a < _b.length; _a++) {\n        var frame = _b[_a];\n\n        if (!frame) {\n          continue;\n        }\n\n        if (frame.percent || frame.percent === 0) {\n          var valueIndex = animation.pixelBased ? \'px\' : \'ms\';\n          var startValueIndex = animation.pixelBased ? \'startPx\' : \'startMs\';\n          var timeline = void 0;\n\n          if (animation.pixelBased) {\n            timeline = pixelTimelineStates[animation.timelineId];\n          } else {\n            timeline = timelineStates[animation.timelineId];\n          }\n\n          var percent = Math.min(Math.max(frame.percent, 0), 100);\n          frame[valueIndex] = timeline && timeline.duration ? frame[startValueIndex] + (timeline.duration - frame[startValueIndex]) * (percent / 100) : frame[valueIndex];\n        }\n      }\n    }\n  }\n};\nvar processAnimationData = function processAnimationData() {\n  core_setupBreakpointHandler();\n  processTimelines();\n  processProcentueelValues();\n};\nvar getAnimationData = function getAnimationData() {\n  return core_animationData;\n};\nvar getPixelTimelineStates = function getPixelTimelineStates() {\n  return pixelTimelineStates;\n};\nvar getTimelineStates = function getTimelineStates() {\n  return timelineStates;\n};\nvar core_setAnimationData = function setAnimationData(data) {\n  core_animationData = data;\n\n  if (core_animationData.numbers) {\n    Object(number_variables["e" /* setNumberVariables */])(core_animationData.numbers, true);\n  }\n};\nvar onUpdateAnimationData = function onUpdateAnimationData(callback) {\n  onUpdateAnimationDataCallback = callback;\n};\nvar core_updateAnimationData = function updateAnimationData(animationDataValue) {\n  window.cancelAnimationFrame(animationFrameId);\n  pixelTimelineStates = resetTimelineStateEnds(pixelTimelineStates);\n  timelineStates = resetTimelineStateEnds(timelineStates);\n  core_animationData = animationDataValue;\n\n  if (core_animationData.numbers) {\n    Object(number_variables["e" /* setNumberVariables */])(core_animationData.numbers, true);\n  }\n\n  core_elements = {};\n  core_animations = [];\n  processAnimationData();\n  requestAnimationFrame(loopUpdateAnimations);\n\n  if (onUpdateAnimationDataCallback) {\n    onUpdateAnimationDataCallback(core_animationData);\n  }\n};\n// CONCATENATED MODULE: ../variojs/lib/data/frame.js\nvar frame_assign = undefined && undefined.__assign || function () {\n  frame_assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return frame_assign.apply(this, arguments);\n};\n\nvar frame_spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\nvar frame_editFrame = function editFrame(animationData, animationDefinitionId, propType, frame) {\n  var _a;\n\n  var animationDefinition = animationDefinition_getAnimationDefinitionById(animationData, animationDefinitionId);\n\n  if (!animationDefinition) {\n    throw errors["d" /* AnimationDefinitionNotFound */];\n  }\n\n  var frames = animationDefinition.props && animationDefinition.props[propType] ? animationDefinition.props[propType] : [];\n  return animationDefinition_editAnimationDefinition(animationData, frame_assign(frame_assign({}, animationDefinition), {\n    props: frame_assign(frame_assign({}, animationDefinition.props), (_a = {}, _a[propType] = (frames || []).map(function (frameTarget) {\n      if (frameTarget.id === frame.id) {\n        return frame_assign(frame_assign({}, frameTarget), frame);\n      }\n\n      return frameTarget;\n    }), _a))\n  }));\n};\nvar frame_addFrame = function addFrame(animationData, animationDefinitionId, propType, frame) {\n  var _a;\n\n  var animationDefinition = animationDefinition_getAnimationDefinitionById(animationData, animationDefinitionId);\n\n  if (!animationDefinition) {\n    throw errors["d" /* AnimationDefinitionNotFound */];\n  }\n\n  var frames = animationDefinition.props && animationDefinition.props[propType] ? animationDefinition.props[propType] : [];\n  var id = frame.id ? frame.id : uuidv4();\n\n  if (frames && frames.find(function (frameFound) {\n    return frameFound.id && frameFound.id === id;\n  })) {\n    throw errors["h" /* FrameIdAlreadyUsed */];\n  }\n\n  return animationDefinition_editAnimationDefinition(animationData, frame_assign(frame_assign({}, animationDefinition), {\n    props: frame_assign(frame_assign({}, animationDefinition.props), (_a = {}, _a[propType] = frame_spreadArrays(frames || [], [frame_assign(frame_assign({}, frame), {\n      id: id\n    })]), _a))\n  }));\n};\nvar frame_deleteFrame = function deleteFrame(animationData, animationDefinitionId, propType, frameId) {\n  var _a;\n\n  var animationDefinition = animationDefinition_getAnimationDefinitionById(animationData, animationDefinitionId);\n\n  if (!animationDefinition) {\n    throw errors["d" /* AnimationDefinitionNotFound */];\n  }\n\n  var frames = animationDefinition.props && animationDefinition.props[propType] ? animationDefinition.props[propType] : [];\n  return animationDefinition_editAnimationDefinition(animationData, frame_assign(frame_assign({}, animationDefinition), {\n    props: frame_assign(frame_assign({}, animationDefinition.props), (_a = {}, _a[propType] = (frames || []).reduce(function (result, frameTarget) {\n      if (frameTarget.id != frameId) {\n        result.push(frameTarget);\n      }\n\n      return result;\n    }, []), _a))\n  }));\n};\n// CONCATENATED MODULE: ../variojs/lib/units-map.js\nvar units_map_a;\n\n\nvar unitMap = (units_map_a = {}, units_map_a[PropTypes.translateX] = [Units.px, Units.em, Units.percent, Units.rem, Units.vh, Units.vw], units_map_a[PropTypes.translateY] = [Units.px, Units.em, Units.percent, Units.rem, Units.vh, Units.vw], units_map_a[PropTypes.width] = [Units.px, Units.em, Units.percent, Units.rem, Units.vh, Units.vw], units_map_a[PropTypes.height] = [Units.px, Units.em, Units.percent, Units.rem, Units.vh, Units.vw], units_map_a[PropTypes.scaleX] = [Units.percent], units_map_a[PropTypes.scaleY] = [Units.percent], units_map_a[PropTypes.rotate] = [Units.deg], units_map_a[PropTypes.opacity] = [Units.percent], units_map_a);\n// CONCATENATED MODULE: ../variojs/lib/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //API\n\n/* harmony default export */ var lib = ({\n  init: core_init,\n  play: play,\n  pause: pause,\n  getAnimationEntryById: function getAnimationEntryById(animationEntryId) {\n    return animationEntry_getAnimationEntryById(getAnimationData(), animationEntryId);\n  },\n  //ANIMATION ENTRY\n  addAnimationEntry: function addAnimationEntry(animationEntry) {\n    core_updateAnimationData(animationEntry_addAnimationEntry(getAnimationData(), animationEntry));\n  },\n  editAnimationEntry: function editAnimationEntry(animationEntry) {\n    core_updateAnimationData(animationEntry_editAnimationEntry(getAnimationData(), animationEntry));\n  },\n  deleteAnimationEntry: function deleteAnimationEntry(animationEntryId) {\n    core_updateAnimationData(animationEntry_deleteAnimationEntry(getAnimationData(), animationEntryId));\n  },\n  editAnimationEntryConnection: function editAnimationEntryConnection(animationEntryId, animationConnection, local) {\n    if (local === void 0) {\n      local = false;\n    }\n\n    core_updateAnimationData(animationEntry_editAnimationEntryConnection(getAnimationData(), animationEntryId, animationConnection, local));\n  },\n  deleteAnimationEntryConnection: function deleteAnimationEntryConnection(animationEntryId, animationDefinitionId, local) {\n    if (local === void 0) {\n      local = false;\n    }\n\n    core_updateAnimationData(animationEntry_deleteAnimationEntryConnection(getAnimationData(), animationEntryId, animationDefinitionId, local));\n  },\n  addAnimationEntryConnection: function addAnimationEntryConnection(animationEntryId, animationConnection, local) {\n    if (local === void 0) {\n      local = false;\n    }\n\n    core_updateAnimationData(animationEntry_addAnimationEntryConnection(getAnimationData(), animationEntryId, animationConnection, local));\n  },\n  //ANIMATION DEFINITION\n  getAnimationDefinitionById: function getAnimationDefinitionById(animationDefinitionId) {\n    return animationDefinition_getAnimationDefinitionById(getAnimationData(), animationDefinitionId);\n  },\n  deleteAnimationDefinition: function deleteAnimationDefinition(animationDefinitionId) {\n    core_updateAnimationData(animationDefinition_deleteAnimationDefinition(getAnimationData(), animationDefinitionId));\n  },\n  addAnimationDefinition: function addAnimationDefinition(animationDefinition) {\n    core_updateAnimationData(animationDefinition_addAnimationDefinition(getAnimationData(), animationDefinition));\n  },\n  editAnimationDefinition: function editAnimationDefinition(animationDefinition) {\n    core_updateAnimationData(animationDefinition_editAnimationDefinition(getAnimationData(), animationDefinition));\n  },\n  //TIMELINE\n  getTimelineById: function getTimelineById(timelineId) {\n    return timeline_getTimelineById(getAnimationData(), timelineId);\n  },\n  addTimeline: function addTimeline(timeline) {\n    core_updateAnimationData(timeline_addTimeline(getAnimationData(), timeline));\n  },\n  editTimeline: function editTimeline(timeline) {\n    core_updateAnimationData(timeline_editTimeline(getAnimationData(), timeline));\n  },\n  deleteTimeline: function deleteTimeline(timelineId) {\n    core_updateAnimationData(timeline_deleteTimeline(getAnimationData(), timelineId));\n  },\n  connectTimelineAnimationEntry: function connectTimelineAnimationEntry(timelineId, animationEntryId) {\n    core_updateAnimationData(timeline_connectTimelineAnimationEntry(getAnimationData(), timelineId, animationEntryId));\n  },\n  disconnectTimelineAnimationEntry: function disconnectTimelineAnimationEntry(timelineId, animationEntryId) {\n    core_updateAnimationData(timeline_disconnectTimelineAnimationEntry(getAnimationData(), timelineId, animationEntryId));\n  },\n  //BREAKPOINT\n  addBreakpoint: function addBreakpoint(breakpoint) {\n    core_updateAnimationData(breakpoints_addBreakpoint(getAnimationData(), breakpoint));\n  },\n  editBreakpoint: function editBreakpoint(breakpoint) {\n    core_updateAnimationData(breakpoints_editBreakpoint(getAnimationData(), breakpoint));\n  },\n  deleteBreakpoint: function deleteBreakpoint(breakpointId) {\n    core_updateAnimationData(breakpoints_deleteBreakpoint(getAnimationData(), breakpointId));\n  },\n  getActiveBreakPoint: function getActiveBreakPoint() {\n    return breakpoints_getActiveBreakPoint(getAnimationData());\n  },\n  //NUMBER VARIABLES\n  addEditNumberVariable: function addEditNumberVariable(name, value) {\n    Object(number_variables["a" /* addEditNumberVariable */])(name, value);\n\n    core_updateAnimationData(getAnimationData());\n  },\n  deleteNumberVariable: function deleteNumberVariable(name) {\n    Object(number_variables["c" /* deleteNumberVariable */])(name);\n\n    core_updateAnimationData(getAnimationData());\n  },\n  //FRAME\n  addFrame: function addFrame(animationDefinitionId, propType, frame) {\n    core_updateAnimationData(frame_addFrame(getAnimationData(), animationDefinitionId, propType, frame));\n  },\n  editFrame: function editFrame(animationDefinitionId, propType, frame) {\n    core_updateAnimationData(frame_editFrame(getAnimationData(), animationDefinitionId, propType, frame));\n  },\n  deleteFrame: function deleteFrame(animationDefinitionId, propType, frameId) {\n    core_updateAnimationData(frame_deleteFrame(getAnimationData(), animationDefinitionId, propType, frameId));\n  },\n  updateAnimationData: core_updateAnimationData,\n  getAnimationData: getAnimationData,\n  getPixelTimelineStates: getPixelTimelineStates,\n  getTimelineStates: getTimelineStates,\n  onUpdateAnimationData: onUpdateAnimationData,\n  getNumbers: number_variables["d" /* getNumbers */]\n});\n// CONCATENATED MODULE: ./src/socket-server/client/socket-connect.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nvar socket_connect_ws;\n/* harmony default export */ var socket_connect = (/*#__PURE__*/(function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(port) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!socket_connect_ws) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt("return", socket_connect_ws);\n\n          case 2:\n            return _context.abrupt("return", new Promise(function (resolve) {\n              socket_connect_ws = new WebSocket("ws://localhost:".concat(port));\n              socket_connect_ws.addEventListener(\'open\', function (event) {\n                resolve(socket_connect_ws);\n              });\n            }));\n\n          case 3:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n})());\n// CONCATENATED MODULE: ./src/lib.js\nfunction lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction lib_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { lib_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nvar lib_WebSocket = __webpack_require__(2);\n\n\n\n\nvar sendSiteData = function sendSiteData(ws, variojs) {\n  var animationData = variojs.getAnimationData();\n  var timelineStates = variojs.getTimelineStates();\n  var pixelTimelineStates = variojs.getPixelTimelineStates();\n\n  if (!animationData) {\n    return;\n  }\n\n  var domNodes = [].slice.call(document.querySelectorAll(\'[data-v]\'));\n  ws.send(JSON.stringify({\n    action: \'siteData\',\n    payload: {\n      animationData: animationData,\n      numbers: variojs.getNumbers(),\n      siteUrl: window.location.href,\n      timelineStates: timelineStates,\n      pixelTimelineStates: pixelTimelineStates,\n      placeholders: domNodes.reduce(function (result, domNode) {\n        var name = domNode.getAttribute(\'data-v\');\n\n        if (name && name != "") {\n          result.push(name);\n        }\n\n        return result;\n      }, [])\n    }\n  }));\n};\n\nvar getPortParam = function getPortParam() {\n  var url = new URL(window.location);\n  var portParam = url.searchParams.get("variojsp");\n  return portParam || \'\';\n};\n\n/* harmony default export */ var src_lib = __webpack_exports__["default"] = ({\n  init: function () {\n    var _init = lib_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(variojs) {\n      var port, ws;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              port = getPortParam();\n\n              if (port) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt("return");\n\n            case 3:\n              _context.next = 5;\n              return socket_connect(port);\n\n            case 5:\n              ws = _context.sent;\n              variojs.onUpdateAnimationData(function (animationData) {\n                sendSiteData(ws, variojs);\n              });\n              window.addEventListener(\'scroll\', function () {\n                ws.send(JSON.stringify({\n                  action: \'calculatePageScroll\',\n                  payload: calculatePageScroll()\n                }));\n              });\n              sendSiteData(ws, variojs);\n              ws.addEventListener(\'message\', function (event) {\n                var data = event.data;\n                var dataParsed = JSON.parse(data);\n\n                if (dataParsed.action === \'updateAnimationData\' && dataParsed.payload.url === window.location.href) {\n                  console.log(dataParsed.payload.animationData);\n                  variojs.updateAnimationData(dataParsed.payload.animationData);\n                  sendSiteData(ws, variojs);\n                }\n\n                if (dataParsed.action === \'getAnimationData\') {\n                  sendSiteData(ws, variojs);\n                }\n              });\n\n            case 10:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function init(_x) {\n      return _init.apply(this, arguments);\n    }\n\n    return init;\n  }()\n});\n\n//# sourceURL=webpack:///./src/lib.js_+_16_modules?')}])}));